.TH QN_STOR_PUT_FILE 3 "NOVEMBER 2016" "Qiniu Cloud" "User Manuals"
.SH NAME
qn_stor_put_file \- upload a local file in one HTTP round trip
.SH SYNOPSIS
.nf
.B #include <qiniu/storage.h>
.sp
.BI "qn_json_object_ptr qn_stor_put_file(qn_storage_ptr restrict " stor ", const qn_stor_auth_ptr restrict " auth ", const char * restrict " fname ", qn_stor_put_extra_ptr restrict " ext ");"
.fi
.SH DESCRIPTION
.BR qn_stor_put_file ()
uploads a local file specified by 
.I fname
in one HTTP round trip and put it into the destination bucket. It's the simplest way to upload a file to Qiniu Cloud Storage.

.I auth
is a mandatory parameter which carries encryption information for creating appropriate token used in the `Authorization` HTTP header. Its definition is

    typedef struct _QN_STOR_AUTH
    {
        struct {
            qn_mac_ptr mac;
            qn_json_object_ptr put_policy;
        } server_end;

        struct {
            union {
                const qn_string acctoken;
                const qn_string uptoken;
            };
        } client_end;
    } qn_stor_auth, *qn_stor_auth_ptr;

If the SDK is used in a secured environment, such as a server, the caller can just fill in the put policy with the access and secret keys directly. qn_stor_put_file() will generate the uptoken before sends the request. Otherwise, it's strongly recommended that NEVER put the secret key in an unsecured and trustless environment like mobile devices since there is a high possibility to be hacked.

.SH RETURN VALUE
If succeeds, 
.BR qn_stor_put_file ()
returns a JSON object contains meta information fields about the uploaded file, and some option fields such as transform job ID. So it has a basic structure looks like the following:

    {
        "fn-code":       <The HTTP code of the response>,
        "fn-error":     "<The HTTP message of the response>",

        "fsize":         <File's size in bytes>,
        "hash":         "<File's hash digest generated by Qiniu-ETAG algorithm>",
        "mimeType":     "<File's MIME type>",
        "putTime":       <File's last upload timestamp>,

        "persistentId":  <Data transformation job ID>
    }

The 
.B fn-code 
and 
.B fn-error 
fields contain the HTTP response's status code and message, respectively. Both are always returned when the response returns successfully, no matter the API operation succeeds or not. Other fields are returned only when the API operation succeeds.

All possible HTTP codes and corresponding messages list as follow.

    +-------+-------------------------------------------------------+
    | Code  | Message                                               |
    +-------+-------------------------------------------------------+
    | 200   | OK.                                                   |
    +-------+-------------------------------------------------------+
    | 400   | Invalid HTTP request.                                 |
    +-------+-------------------------------------------------------+
    | 401   | Bad access token (failed in authorization check).     |
    +-------+-------------------------------------------------------+
    | 599   | Server failed due to unknown reason and CONTACT US!   |
    +-------+-------------------------------------------------------+
    | 614   | File exists.                                          |
    +-------+-------------------------------------------------------+
    | 631   | Bucket doesn't exist.                                 |
    +-------+-------------------------------------------------------+

If fails, 
.BR qn_stor_put_file ()
returns a NULL value and an immediate call to
.BR qn_err_get_message ()
will return a message string to describe what happened.
